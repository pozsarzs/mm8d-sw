#!/usr/bin/python3
# +----------------------------------------------------------------------------+
# | MM8D v0.6 * Growing house and irrigation controlling and monitoring system |
# | Copyright (C) 2020-2024 Pozs√°r Zsolt <pozsarzs@gmail.com>                  |
# | mm8d.py                                                                    |
# | Main program                                                               |
# +----------------------------------------------------------------------------+
#
#   This program is free software: you can redistribute it and/or modify it
# under the terms of the European Union Public License 1.2 version.
#
#   This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.
# 
# Exit codes:
#   0: normal exit
#   1: cannot open configuration file
#  14: cannot open environment characteristic configuration file
#  15: cannot create log file
#  17: cannot access i/o port
#  18: there is not enabled channel
#  19: fatal error
#  20: cannot open irrigator configuration file
 
import configparser
import daemon
import io
import json
import os
import platform
import requests
import serial
import sys
import time
from pymodbus.client import ModbusSerialClient
from pymodbus.client import ModbusTcpClient
from time import localtime, strftime

# constants
arch=platform.machine()
if arch.find('86') > -1:
  HW = 1
  import portio
else:
  HW = 0
  import RPi.GPIO as GPIO

# constants
CONFDIR='@prefix@/etc/mm8d/'
COMPMV6=0
COMPSV6=4
COMPMV7=0
COMPSV7=4
DELAY=3

global EOL
global LPTADDRESSES
EOL = '\r'
MB_PORT = 502

# add a zero char
def addzero(num):
  if num < 10:
    z = '0'
  else:
    z = ''
  s = z + str(num)
  return s

# write a line to debug logfile
def writedebuglog(level, text):
  if level == 'i':
    if msc_verbose > 2:
      writedebuglogtocomport(level, text)
  if level == 'w':
    if msc_verbose > 1:
      writedebuglogtocomport(level, text)
  if level == 'e':
    if msc_verbose > 0:
      writedebuglogtocomport(level, text)
  if log_debug == 1:
    if level == 'i':
      lv = 'INFO   '
    if level == 'w':
      lv = 'WARNING'
    if level == 'e':
      lv = 'ERROR  '
    debugfile = dir_log + '/' + time.strftime('debug-%Y%m%d.log')
    dt = (strftime('%Y-%m-%d %H:%M:%S', localtime()))
    try:
      with open(debugfile, 'a') as d:
        d.write(dt + '  ' + lv + ' ' + text + '\n')
        d.close()
    except:
      print ('')

# write a debug log line to serial console
def writedebuglogtocomport(level, text):
  if msc_enable == 1:
    dt = (strftime('%y%m%d %H%M%S', localtime()))
    try:
      com.open
      com.write(str.encode(dt + ' ' + str.upper(level) + ' ' + text + EOL))
      com.close
      time.sleep(0.1)
    except:
      print('writedebuglogtocomport')

# send channels' data to serial console
def writechannelstatustocomport(channel):
  transmitbuffer = [0x00 for x in range(13)]
  line = ''
  if msc_enable == 1:
    if channel == 0:
      transmitbuffer[0x00] = ord('C')
      transmitbuffer[0x01] = ord('H')
      transmitbuffer[0x02] = channel
      transmitbuffer[0x03] = mainsbreakers
      transmitbuffer[0x04] = waterpressurelow
      transmitbuffer[0x05] = waterpressurehigh
      if exttemp > 0:
        transmitbuffer[0x06] = exttemp
      else:
        transmitbuffer[0x06] = 0x00
      transmitbuffer[0x07] = relay_tube1
      transmitbuffer[0x08] = relay_tube2
      transmitbuffer[0x09] = relay_tube3
      transmitbuffer[0x0A] = 0x00
      transmitbuffer[0x0B] = 0x00
      transmitbuffer[0x0C] = 0x00
      if override[channel][1] == 'on':
        transmitbuffer[0x07] = 0x03
      if override[channel][1] == 'off':
        transmitbuffer[0x07] = 0x02
      if override[channel][2] == 'on':
        transmitbuffer[0x08] = 0x03
      if override[channel][2] == 'off':
        transmitbuffer[0x08] = 0x02
      if override[channel][3] == 'on':
        transmitbuffer[0x09] = 0x03
      if override[channel][3] == 'off':
        transmitbuffer[0x09] = 0x02
    else:
      transmitbuffer[0x00] = ord('C')
      transmitbuffer[0x01] = ord('H')
      transmitbuffer[0x02] = channel
      transmitbuffer[0x03] = in_temperature[channel]
      transmitbuffer[0x04] = in_humidity[channel]
      transmitbuffer[0x05] = 0
      transmitbuffer[0x06] = in_opmode[channel]
      transmitbuffer[0x07] = in_swmanu[channel]
      transmitbuffer[0x08] = in_ocprot[channel]
      transmitbuffer[0x09] = in_alarm[channel]
      transmitbuffer[0x0A] = out_lamps[channel]
      transmitbuffer[0x0B] = out_vents[channel]
      transmitbuffer[0x0C] = out_heaters[channel]
      if override[channel][1] == 'on':
        transmitbuffer[0x0A] = 0x03
      if override[channel][1] == 'off':
        transmitbuffer[0x0A] = 0x02
      if override[channel][2] == 'on':
        transmitbuffer[0x0B] = 0x03
      if override[channel][2] == 'off':
        transmitbuffer[0x0B] = 0x02
      if override[channel][3] == 'on':
        transmitbuffer[0x0C] = 0x03
      if override[channel][3] == 'off':
        transmitbuffer[0x0C] = 0x02
      if ch_enable[channel] == 0:
        transmitbuffer[0x06] = 0x7F
    try:
      com.open
      com.write(transmitbuffer)
      com.close
      time.sleep(0.1)
    except:
      print('writechannelstatustocomport')

# load configuration
def loadconfiguration(conffile):
  global ch_enable
  global dir_log
  global dir_var
  global fwm_enable
  global fwm_handler
  global fwm_modbusid
  global fwm_port
  global fwm_speed
  global lockfile
  global log_debug
  global logfile
  global mm6d_intthermostat
  global mm6d_port
  global mm6d_protocol
  global mm6d_speed
  global mm6dch_ipaddress
  global mm6dch_modbusid
  global mm7d_port
  global mm7d_protocol
  global mm7d_speed
  global mm7dch_ipaddress
  global mm7dch_modbusid
  global msc_enable
  global msc_port
  global msc_speed
  global msc_verbose
  global otm_enable
  global otm_handler
  global otm_modbusid
  global otm_port
  global otm_speed
  global owm_apikey
  global owm_city
  global owm_enable
  global owm_url
  global pwm_enable
  global pwm_handler
  global pwm_modbusid
  global pwm_port
  global pwm_speed
  global tdp_enable
  global tdp_handler
  global tdp_port
  global tdp_speed
  global tdpch_modbusid
  if (HW == 0):
    global gpio_i1
    global gpio_i2
    global gpio_i3
    global gpio_i4
    global gpio_i5
    global gpio_lo1
    global gpio_lo2
    global gpio_lo3
    global gpio_lo4
    global gpio_ro1
    global gpio_ro1
    global gpio_ro2
    global gpio_ro3
    global gpio_ro5
    global gpio_ro6
    global gpio_ro7
    global gpio_ro8
  else:
    global ipc_gpio_enable
    global ipc_gpio_handler
    global ipc_gpio_i1
    global ipc_gpio_i2
    global ipc_gpio_i3
    global ipc_gpio_i4
    global ipc_gpio_ro1
    global ipc_gpio_ro2
    global ipc_gpio_ro3
    global ipc_gpio_ro4
    global ipc_led_alarm
    global ipc_led_enable
    global ipc_led_status
    global lpt_address
    global lpt_bits
  C = 'channels'
  D = 'directories'
  F = 'flowmeter'
  I = 'localio'
  L = 'log'
  M6 = 'mm6d'
  M7 = 'mm7d'
  O = 'openweathermap.org'
  P = 'powermeter'
  S = 'console'
  T = 'outdoortempmeter'
  Y = 'tentdisplay'
  try:
    with open(conffile) as f:
      mainconfig = f.read()
    config = configparser.RawConfigParser(allow_no_value = True)
    config.read_file(io.StringIO(mainconfig))
    # enable/disable channels
    ch_enable = [0 for x in range(9)]
    for i in range(1,9):
      ch_enable[i] = int(config.get(C, 'ch' + str(i) + '_enable'))
    # create verbose debug log file
    log_debug = 0
    log_debug = int(config.get(L, 'log_debug'))
    # directories of program
    dir_log = config.get(D, 'dir_log')
    dir_var = config.get(D, 'dir_var')
    lockfile = config.get(D, 'dir_lck') + 'mm8d.lck'
    # openweather.org access data
    owm_apikey = config.get(O, 'owm_apikey')
    owm_city = config.get(O, 'owm_city')
    owm_enable = 0
    owm_enable = int(config.get(O, 'owm_enable'))
    owm_url = config.get(O, 'owm_url')
    # local ports
    if HW == 0:
      gpio_i1 = int(config.get(I, 'gpio_i1'))
      gpio_i2 = int(config.get(I, 'gpio_i2'))
      gpio_i3 = int(config.get(I, 'gpio_i3'))
      gpio_i4 = int(config.get(I, 'gpio_i4'))
      gpio_i5 = int(config.get(I, 'gpio_i5'))
      gpio_lo1 = int(config.get(I, 'gpio_lo1'))
      gpio_lo2 = int(config.get(I, 'gpio_lo2'))
      gpio_lo3 = int(config.get(I, 'gpio_lo3'))
      gpio_lo4 = int(config.get(I, 'gpio_lo4'))
      gpio_ro1 = int(config.get(I, 'gpio_ro1'))
      gpio_ro2 = int(config.get(I, 'gpio_ro2'))
      gpio_ro3 = int(config.get(I, 'gpio_ro3'))
      gpio_ro4 = int(config.get(I, 'gpio_ro4'))
      gpio_ro5 = int(config.get(I, 'gpio_ro5'))
      gpio_ro6 = int(config.get(I, 'gpio_ro6'))
      gpio_ro7 = int(config.get(I, 'gpio_ro7'))
      gpio_ro8 = int(config.get(I, 'gpio_ro8'))
    else:
      lpt_address = 0x378
      lpt_address = int(config.get(I, 'lpt_address'),16)
      lpt_bits = [[0 for y in range(3)] for x in range(17)]
      for x in range(0,5):
        lpt_bits[x][0] = 1
        lpt_bits[x][1] = int(config.get(I, 'lpt_i' + str(x + 1) + '_bit'))
        lpt_bits[x][2] = int(config.get(I, 'lpt_i' + str(x + 1) + '_negation'))
      for x in range(5,9):
        lpt_bits[x][0] = 2
        lpt_bits[x][1] = int(config.get(I, 'lpt_lo' + str(x - 4) + '_bit'))
        lpt_bits[x][2] = int(config.get(I, 'lpt_lo' + str(x - 4) + '_negation'))
      for x in range(9,17):
        lpt_bits[x][0] = 0
        lpt_bits[x][1] = int(config.get(I, 'lpt_ro' + str(x - 8) + '_bit'))
        lpt_bits[x][2] = int(config.get(I, 'lpt_ro' + str(x - 8) + '_negation'))
      for x in range(0,17):
        lpt_bits[x][2] = 1 if lpt_bits[x][2] >= 1 else 0
      ipc_gpio_enable = 0
      ipc_gpio_enable = int(config.get(I, 'ipc_gpio_enable'))
      ipc_gpio_handler = ''
      ipc_gpio_handler = config.get(I, 'ipc_gpio_handler')
      ipc_gpio_i1 = int(config.get(I, 'ipc_gpio_i1'))
      ipc_gpio_i2 = int(config.get(I, 'ipc_gpio_i2'))
      ipc_gpio_i3 = int(config.get(I, 'ipc_gpio_i3'))
      ipc_gpio_i4 = int(config.get(I, 'ipc_gpio_i4'))
      ipc_gpio_ro1 = int(config.get(I, 'ipc_gpio_ro1'))
      ipc_gpio_ro2 = int(config.get(I, 'ipc_gpio_ro2'))
      ipc_gpio_ro3 = int(config.get(I, 'ipc_gpio_ro3'))
      ipc_gpio_ro4 = int(config.get(I, 'ipc_gpio_ro4'))
      ipc_led_alarm = 0
      ipc_led_alarm = int(config.get(I, 'ipc_led_alarm'))
      ipc_led_enable = 0
      ipc_led_enable = int(config.get(I, 'ipc_led_enable'))
      ipc_led_status = 1
      ipc_led_status = int(config.get(I, 'ipc_led_status'))
    # serial console
    msc_enable = 0
    msc_enable = int(config.get(S, 'msc_enable'))
    msc_port = '/dev/ttyS0'
    msc_port = config.get(S, 'msc_port')
    msc_speed = 9600
    msc_speed = int(config.get(S, 'msc_speed'))
    msc_verbose = 0
    msc_verbose = int(config.get(S, 'msc_verbose'))
    # power meter
    pwm_enable = 0
    pwm_enable = int(config.get(P, 'pwm_enable'))
    pwm_handler = ''
    pwm_handler = config.get(P, 'pwm_handler')
    pwm_modbusid = 0
    pwm_modbusid = int(config.get(P, 'pwm_modbusid'))
    pwm_port = '/dev/ttyS1'
    pwm_port = config.get(P, 'pwm_port')
    pwm_speed = 9600
    pwm_speed = int(config.get(P, 'pwm_speed'))
    # flow meter
    fwm_enable = 0
    fwm_enable = int(config.get(F, 'fwm_enable'))
    fwm_handler = ''
    fwm_handler = config.get(F, 'fwm_handler')
    fwm_modbusid = 0
    fwm_modbusid = int(config.get(F, 'fwm_modbusid'))
    fwm_port = '/dev/ttyS1'
    fwm_port = config.get(F, 'fwm_port')
    fwm_speed = 9600
    fwm_speed = int(config.get(F, 'fwm_speed'))
    # outdoor temperature meter
    otm_enable = 0
    otm_enable = int(config.get(T, 'otm_enable'))
    otm_handler = ''
    otm_handler = config.get(T, 'otm_handler')
    otm_modbusid = 0
    otm_modbusid = int(config.get(T, 'otm_modbusid'))
    otm_port = '/dev/ttyS2'
    otm_port = config.get(T, 'otm_port')
    otm_speed = 9600
    otm_speed = int(config.get(T, 'otm_speed'))
    # tent displays
    tdp_enable = 0
    tdp_enable = int(config.get(Y, 'tdp_enable'))
    tdp_handler = ''
    tdp_handler = config.get(Y, 'tdp_handler')
    tdpch_modbusid = [0 for x in range(1,10)]
    for i in range(1,9):
      tdpch_modbusid[i] = int(config.get(Y, 'tdpch' + str(i) + '_modbusid'))
    tdp_port = '/dev/ttyS3'
    tdp_port = config.get(Y, 'tdp_port')
    tdp_speed = 9600
    tdp_speed = int(config.get(Y, 'tdp_speed'))
    # MM6D devices
    mm6d_protocol = 'http'
    mm6d_protocol = config.get(M6, 'mm6d_protocol')
    mm6d_port = '/dev/ttyS3'
    mm6d_port = config.get(M6, 'mm6d_port')
    mm6d_speed = 9600
    mm6d_speed = int(config.get(M6, 'mm6d_speed'))
    mm6d_intthermostat = 0
    mm6d_intthermostat = int(config.get(M6, 'mm6d_intthermostat'))
    mm6dch_modbusid = [0 for x in range(1,10)]
    mm6dch_ipaddress = [0 for x in range(1,10)]
    for i in range(1,9):
      mm6dch_modbusid[i] = int(config.get(M6, 'mm6dch' + str(i) + '_modbusid'))
      mm6dch_ipaddress[i] = config.get(M6, 'mm6dch' + str(i) + '_ipaddress')
    # MM7D devices
    mm7d_protocol = 'http'
    mm7d_protocol = config.get(M7, 'mm7d_protocol')
    mm7d_port = '/dev/ttyS3'
    mm7d_port = config.get(M7, 'mm7d_port')
    mm7d_speed = 9600
    mm7d_speed = int(config.get(M7, 'mm7d_speed'))
    mm7dch_modbusid = [0 for x in range(1,10)]
    mm7dch_ipaddress = [0 for x in range(1,10)]
    for i in range(1,9):
      mm7dch_modbusid[i] = int(config.get(M7, 'mm7dch' + str(i) + '_modbusid'))
      mm7dch_ipaddress[i] = config.get(M7, 'mm7dch' + str(i) + '_ipaddress')
    writedebuglog('i', 'Configuration is loaded.')
  except:
    writedebuglog('e', 'ERROR #01: Cannot open or read ' + conffile + '!')
    exit(1)

# load configuration
def loadirrconf(conffile):
  C = 'common'
  T = 'tube-'
  global irenable
  global irevening_start
  global irevening_stop
  global irmorning_start
  global irmorning_stop
  global irtemp_max
  global irtemp_min
  irenable = [0 for channel in range(4)]
  irevening_start = [0 for channel in range(4)]
  irevening_stop = [0 for channel in range(4)]
  irmorning_start = [0 for channel in range(4)]
  irmorning_stop = [0 for channel in range(4)]
  irtemp_max = 0
  irtemp_min = 0
  try:
    with open(conffile) as f:
      mainconfig = f.read()
    config = configparser.RawConfigParser(allow_no_value = True)
    config.read_file(io.StringIO(mainconfig))
    irtemp_max = int(config.get(C, 'temp_max'))
    irtemp_min = int(config.get(C, 'temp_min'))
    for i in range(1,4):
      irenable[i] = config.get(T + str(i), 'enable')
      irevening_start[i] = config.get(T + str(i), 'evening_start')
      irevening_stop[i] = config.get(T + str(i), 'evening_stop')
      irmorning_start[i] = config.get(T + str(i), 'morning_start')
      irmorning_stop[i] = config.get(T + str(i), 'morning_stop')
    writedebuglog('i', 'Irrigator configuration is loaded.')
  except:
    writedebuglog('e', 'ERROR #20: Cannot open ' + conffile + '!')
    exit(20)
 
# load environment characteristics
def loadenvirconf(channel,conffile):
  H = 'hyphae'
  M = 'mushroom'
  try:
    with open(conffile) as f:
      envir_config = f.read()
    config = configparser.RawConfigParser(allow_no_value = True)
    config.read_file(io.StringIO(envir_config))
    hhumidifier_off[channel] = int(config.get(H, 'humidifier_off'))
    hhumidity_max[channel] = int(config.get(H, 'humidity_max'))
    hhumidity_min[channel] = int(config.get(H, 'humidity_min'))
    hhumidifier_on[channel] = int(config.get(H, 'humidifier_on'))
    htemperature_max[channel] = int(config.get(H, 'temperature_max'))
    hheater_off[channel] = int(config.get(H, 'heater_off'))
    hheater_on[channel] = int(config.get(H, 'heater_on'))
    htemperature_min[channel] = int(config.get(H, 'temperature_min'))
    for x in range(24):
      hheater_disable[x][channel] = int(config.get(H, 'heater_disable_' + addzero(x)))
    hlight_on1[channel] = int(config.get(H, 'light_on1'))
    hlight_off1[channel] = int(config.get(H, 'light_off1'))
    hlight_on2[channel] = int(config.get(H, 'light_on2'))
    hlight_off2[channel] = int(config.get(H, 'light_off2'))
    hvent_on[channel] = int(config.get(H, 'vent_on'))
    hvent_off[channel] = int(config.get(H, 'vent_off'))
    for x in range(24):
      hvent_disable[x][channel] = int(config.get(H, 'vent_disable_' + addzero(x)))
    for x in range(24):
      hvent_disablelowtemp[x][channel] = int(config.get(H, 'vent_disablelowtemp_' + addzero(x)))
    hvent_lowtemp[channel] = int(config.get(H, 'vent_lowtemp'))
    for x in range(24):
      hvent_disablehightemp[x][channel] = int(config.get(H, 'vent_disablehightemp_' + addzero(x)))
    hvent_hightemp[channel] = int(config.get(H, 'vent_hightemp'))
    mhumidifier_off[channel] = int(config.get(M, 'humidifier_off'))
    mhumidity_max[channel] = int(config.get(M, 'humidity_max'))
    mhumidity_min[channel] = int(config.get(M, 'humidity_min'))
    mhumidifier_on[channel] = int(config.get(M, 'humidifier_on'))
    mtemperature_max[channel] = int(config.get(M, 'temperature_max'))
    mheater_off[channel] = int(config.get(M, 'heater_off'))
    mheater_on[channel] = int(config.get(M, 'heater_on'))
    mtemperature_min[channel] = int(config.get(M, 'temperature_min'))
    for x in range(24):
      mheater_disable[x][channel] = int(config.get(M, 'heater_disable_' + addzero(x)))
    mlight_on1[channel] = int(config.get(M, 'light_on1'))
    mlight_off1[channel] = int(config.get(M, 'light_off1'))
    mlight_on2[channel] = int(config.get(M, 'light_on2'))
    mlight_off2[channel] = int(config.get(M, 'light_off2'))
    mvent_on[channel] = int(config.get(M, 'vent_on'))
    mvent_off[channel] = int(config.get(M, 'vent_off'))
    for x in range(24):
      mvent_disable[x][channel] = int(config.get(M, 'vent_disable_' + addzero(x)))
    for x in range(24):
      mvent_disablelowtemp[x][channel] = int(config.get(M, 'vent_disablelowtemp_' + addzero(x)))
    mvent_lowtemp[channel] = int(config.get(M, 'vent_lowtemp'))
    for x in range(24):
      mvent_disablehightemp[x][channel] = int(config.get(M, 'vent_disablehightemp_' + addzero(x)))
    mvent_hightemp[channel] = int(config.get(M, 'vent_hightemp'))
    writedebuglog('i', 'CH' + str(channel) + ': Environment characteristics is loaded.')
  except:
    writedebuglog('e', 'ERROR #14: Cannot open ' + conffile + '!')
    exit(14)

# create and remove lock file
def lckfile(mode):
  try:
    if mode > 0:
      lcf = open(lockfile, 'w')
      lcf.close()
      writedebuglog('i', 'Creating lockfile.')
    else:
      writedebuglog('i', 'Removing lockfile.')
      os.remove(lockfile)
  except:
    writedebuglog('w', 'Cannot create/remove' + lockfile + '.')

# write channel's data to logfile
def writechannelstatustolog(channel,temperature,humidity,statusdata):
  logfile = dir_log + '/mm8d-ch' + str(channel) + '.log'
  dt = (strftime('%Y-%m-%d,%H:%M',localtime()))
  lckfile(1)
  writedebuglog('i', 'CH' + str(channel) + ': Writing channel''s data to logfile.')
  if not os.path.isfile(logfile):
    f = open(logfile, 'w')
    f.close()
  try:
    with open(logfile, 'r+') as f:
      first_line = f.readline()
      lines = f.readlines()
      f.seek(0)
      if (channel == 0):
        s = dt + ', ' + statusdata[0] + ', ' + \
                       statusdata[1] + ', ' + \
                       statusdata[2] + ', ' + \
                       str(temperature) + ', ' + \
                       statusdata[3] + ', ' + \
                       statusdata[4] + ', ' + \
                       statusdata[5] + '\n'
      else:
        s = dt + ', ' + str(temperature) + ', ' + \
                       str(humidity) + ', ' + \
                       statusdata[0] + ', ' + \
                       statusdata[1] + ', ' + \
                       statusdata[2] + ', ' + \
                       statusdata[3] + ', ' + \
                       statusdata[4] + ', ' + \
                       statusdata[5] + ', ' + \
                       statusdata[6] + ', ' + \
                       statusdata[7] + '\n'
      f.write(s)
      f.write(first_line)
      f.writelines(lines)
      f.close()
  except:
    writedebuglog('e', 'ERROR #15: Cannot write ' + logfile + '!')
    lckfile(0)
    exit(15)
  lckfile(0)

# write power supply data to logfile
def writesupplydatatolog(urms, irms, p, q, s, cosfi, qv):
  logfile = dir_log + '/mm8d-supply.log'
  dt = (strftime('%Y-%m-%d,%H:%M',localtime()))
  lckfile(1)
  writedebuglog('i', 'Writing power supply data to logfile.')
  if not os.path.isfile(logfile):
    f = open(logfile, 'w')
    f.close()
  try:
    with open(logfile, 'r+') as f:
      first_line = f.readline()
      lines = f.readlines()
      f.seek(0)
      s = dt + ', ' + str(pwm_urms) + ', ' + \
                     str(pwm_irms) + ', ' + \
                     str(pwm_p) + ', ' + \
                     str(pwm_q) + ', ' + \
                     str(pwm_s) + ', ' + \
                     str(pwm_cosfi) + ', ' + \
                     str(fwm_qv) + '\n'
      f.write(s)
      f.write(first_line)
      f.writelines(lines)
      f.close()
  except:
    writedebuglog('e', 'ERROR #15: Cannot write ' + logfile + '!')
    lckfile(0)
    exit(15)
  lckfile(0)

# check external control files
def outputoverride(channel,output,status):
  writedebuglog('i', 'CH' + str(channel) + ': Checking override file ' + str(output) + '.')
  if os.path.isfile(dir_var + '/' + str(channel) + '/out' + str(output)):
    try:
      f = open(dir_var + '/' + str(channel) + '/out' + str(output), 'r')
      v = f.read()
      f.close()
      if v == 'neutral': s = status
      if v == 'off': s = '0'
      if v == 'on': s = '1'
      override[channel][output] = v
    except:
      s = status
  else:
    s = status
  return s

# get external temperature from openweathermap.org
def getexttemp():
  writedebuglog('i', 'Get external temperature from internet.')
  try:
    response=requests.get(owm_url + 'appid=' + owm_apikey + '&q=' + owm_city)
    x=response.json()
    if x['cod'] != '404':
      y = x['main']
      current_temperature = y['temp']
      current_temperature = round(current_temperature - 273)
      return current_temperature
    else:
      writedebuglog('w', 'Cannot get external temperature from internet.')
      return 18
  except:
    writedebuglog('w', 'Cannot get external temperature from internet.')
    return 18

# analise data
def analise(section):
  global led_error
  global led_warning
  global led_waterpumperror
  global relay_alarm
  global relay_tube1
  global relay_tube2
  global relay_tube3
  h = int(time.strftime('%H'))
  m = int(time.strftime('%M'))
  if section == 1:
    # Local inputs/outputs
    led_error = 0
    led_warning = 0
    led_waterpumperror = 0
    relay_alarm = 0
    relay_tube1 = 0
    relay_tube2 = 0
    relay_tube3 = 0
    # - opened local overcurrent breaker(s)
    if mainsbreakers == 1:
      led_error = 1
      writedebuglog('e', 'Overcurrent breaker is opened!')
    # - switch on/off waterpump and valves
    if (exttemp < irtemp_min):
      relay_tube1 = 0
      relay_tube2 = 0
      relay_tube3 = 0
      writedebuglog('w', 'CH0: External temperature is too low for irrigation! (< ' + str(irtemp_min) + ' C)')
    else:
      if (exttemp > irtemp_max):
        relay_tube1 = 0
        relay_tube2 = 0
        relay_tube3 = 0
        writedebuglog('w', 'CH0: External temperature is too high for irrigation! (> ' + str(irtemp_max) + ' C)')
      else:
        h1, m1 = irmorning_start[1].split(':')
        h2, m2 = irmorning_stop[1].split(':')
        h3, m3 = irevening_start[1].split(':')
        h4, m4 = irevening_stop[1].split(':')
        if ((h * 100 + m >= int(h1) * 100 + int(m1)) and (h * 100 + m < int(h2) * 100 + int(m2))) or \
           ((h * 100 + m >= int(h3) * 100 + int(m3)) and (h * 100 + m < int(h4) * 100 + int(m4))):
          relay_tube1 = 1
        h1, m1 = irmorning_start[2].split(':')
        h2, m2 = irmorning_stop[2].split(':')
        h3, m3 = irevening_start[2].split(':')
        h4, m4 = irevening_stop[2].split(':')
        if ((h*100+m >= int(h1) * 100 + int(m1)) and (h * 100 + m < int(h2) * 100 + int(m2))) or \
           ((h*100+m >= int(h3) * 100 + int(m3)) and (h * 100 + m < int(h4) * 100 + int(m4))):
          relay_tube2 = 1
        h1, m1 = irmorning_start[3].split(':')
        h2, m2 = irmorning_stop[3].split(':')
        h3, m3 = irevening_start[3].split(':')
        h4, m4 = irevening_stop[3].split(':')
        if ((h * 100 + m >= int(h1) * 100 + int(m1)) and (h * 100 + m < int(h2) * 100 + int(m2))) or \
           ((h * 100 + m >= int(h3) * 100 + int(m3)) and (h * 100 + m < int(h4) * 100 + int(m4))):
          relay_tube3 = 1
    if irenable[1] == 0:
      relay_tube1 = 0;
    if irenable[2] == 0:
      relay_tube2 = 0;
    if irenable[3] == 0:
      relay_tube3 = 0;
    # - messages
    if relay_tube1 == 1:
      writedebuglog('i', 'CH0: Output water pump and valve #1 ON')
    else:
      writedebuglog('i', 'CH0: Output water pump and valve #1 OFF')
    if relay_tube2 == 1:
      writedebuglog('i', 'CH0: Output water pump and valve #2 ON')
    else:
      writedebuglog('i', 'CH0: Output water pump and valve #2 OFF')
    if relay_tube3 == 1:
      writedebuglog('i', 'CH0: Output water pump and valve #3 ON')
    else:
      writedebuglog('i', 'CH0: Output water pump and valve #3 OFF')
    # - bad pressure
    if ((relay_tube1 == 1) or (relay_tube2 == 1) or (relay_tube3 == 1)) and (waterpressurelow):
      led_waterpumperror = 1
      writedebuglog('e', 'Pressure is too low after water pump!')
    if ((relay_tube1 == 1) or (relay_tube2 == 1) or (relay_tube3 == 1)) and (waterpressurehigh):
      led_waterpumperror = 1
      writedebuglog('e', 'Pressure is too high after water pump!')
    # MM6D
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        # - opened doors
        if in_alarm[channel] == 1:
          relay_alarm = 1
          led_warning = 1
          writedebuglog('w', 'CH' + str(channel) + ': Alarm event detected.')
        # - bad manual switch position
        if in_swmanu[channel] == 1:
          led_warning = 1
          writedebuglog('w', 'CH' + str(channel) + ': Manual mode switch is on position.')
        # - opened overcurrent breaker(s)
        if in_ocprot[channel] == 1:
          led_error = 1
          writedebuglog('e', 'CH' + str(channel) + ': Overcurrent breaker of MM6D is opened!')
  else:
    # Growing environments
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        wrongdata = in_temperature[channel] + in_humidity[channel]
        writedebuglog('i', 'CH' + str(channel) + ': Measured T is ' + str(in_temperature[channel]) + ' C')
        writedebuglog('i', 'CH' + str(channel) + ': Measured RH is ' + str(in_humidity[channel]) + '%')
        if wrongdata == 0:
          writedebuglog('e', 'CH' + str(channel) + ': Measured data are wrong!')
        if in_opmode[channel] == 2:
          # growing mushroom
          writedebuglog('i', 'CH' + str(channel) + ': Operation mode: growing mushroom.')
          # - bad temperature
          if in_temperature[channel] < mtemperature_min[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Temperature is too low! (' + str(in_temperature[channel]) + ' C < ' + str(mtemperature_min[channel]) + ' C)')
          if in_temperature[channel] > mtemperature_max[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Temperature is too high! (' + str(in_temperature[channel]) + ' C > ' + str(mtemperature_max[channel]) + ' C)')
          # - bad humidity
          if in_humidity[channel] < mhumidity_min[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Relative humidity is too low! (' + str(in_humidity[channel]) + ' % < ' + str(mhumidity_min[channel]) + '%)')
          if in_humidity[channel] > mhumidity_max[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Relative humidity is too high! (' + str(in_humidity[channel]) + ' % > ' + str(mhumidity_max[channel]) + '%)')
          # - heaters
          if wrongdata > 0:
            if mm6d_intthermostat == 0:
              out_heaters[channel] = 0
              if in_temperature[channel] < mheater_on[channel]:
                out_heaters[channel] = 1
              if in_temperature[channel] > mheater_off[channel]:
                out_heaters[channel] = 0
            else:
              out_heaters[channel] = 1
            if mheater_disable[h][channel] == 1:
              out_heaters[channel] = 0
          # - lights
          out_lamps[channel] = 0
          if (h >= mlight_on1[channel]) and (h < mlight_off1[channel]):
            out_lamps[channel] = 1
          if (h >= mlight_on2[channel]) and (h < mlight_off2[channel]):
            out_lamps[channel] = 1
          # - ventilators
          out_vents[channel] = 0
          if (m > mvent_on[channel]) and (m < mvent_off[channel]):
            out_vents[channel] = 1
          if mvent_disable[h][channel] == 1:
            out_vents[channel] = 0
          if (in_humidity[channel] > mhumidity_max[channel]) and (exttemp < mtemperature_max[channel]):
            out_vents[channel] = 1
          if (in_temperature[channel] > mtemperature_max[channel]) and (exttemp < mtemperature_max[channel]):
            out_vents[channel] = 1
        if in_opmode[channel] == 1:
          # growing hyphae
          writedebuglog('i', 'CH' + str(channel) + ': Operation mode: growing hyphae.')
          # - bad temperature
          if in_temperature[channel] < htemperature_min[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Temperature is too low! (' + str(in_temperature[channel]) + ' C < ' + str(htemperature_min[channel]) + ' C)')
          if in_temperature[channel] > htemperature_max[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Temperature is too high! (' + str(in_temperature[channel]) + ' C > ' + str(htemperature_max[channel]) + ' C)')
          # - bad humidity
          if in_humidity[channel] < hhumidity_min[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Relative humidity is too low! (' + str(in_humidity[channel]) + ' % < ' + str(hhumidity_min[channel]) + '%)')
          if in_humidity[channel] > hhumidity_max[channel]:
            writedebuglog('w', 'CH' + str(channel) + ': Relative humidity is too high! (' + str(in_humidity[channel]) + ' % > ' + str(hhumidity_max[channel]) + '%)')
          # - heaters
          if wrongdata > 0:
            if mm6d_intthermostat == 0:
              out_heaters[channel] = 0
              if in_temperature[channel] < hheater_on[channel]:
                out_heaters[channel] = 1
              if in_temperature[channel] > hheater_off[channel]:
                out_heaters[channel] = 0
            else:
              out_heaters[channel] = 1
            if hheater_disable[h][channel] == 1:
              out_heaters[channel] = 0
          # - lights
          out_lamps[channel] = 0
          if (h >= hlight_on1[channel]) and (h < hlight_off1[channel]):
            out_lamps[channel] = 1
          if (h >= hlight_on2[channel]) and (h < hlight_off2[channel]):
            out_lamps[channel] = 1
          # - ventilators
          out_vents[channel] = 0
          if (m > hvent_on[channel]) and (m < hvent_off[channel]):
            out_vents[channel] = 1
          if (in_humidity[channel] > hhumidity_max[channel]) and (exttemp < htemperature_max[channel]):
            out_vents[channel] = 1
          if (in_temperature[channel] > htemperature_max[channel]) and (exttemp < htemperature_max[channel]):
            out_vents[channel] = 1
          if hvent_disablelowtemp[h][channel] == 1:
            out_vents[channel] = 0
          if hvent_disablehightemp[h][channel] == 1:
            out_vents[channel] = 0
        if (in_opmode[channel] == 0):
          # stand-by
          writedebuglog('i', 'CH' + str(channel) + ': Operation mode: stand-by.')
          # - heaters
          out_heaters[channel] = 0
          # - lights
          out_lamps[channel] = 0
          # - ventilators
          out_vents[channel] = 0
        # messages
        if out_heaters[channel] == 1:
          writedebuglog('i', 'CH' + str(channel) + ': Output heaters ON')
        else:
          writedebuglog('i', 'CH' + str(channel) + ': Output heaters OFF')
        if out_lamps[channel] == 1:
          writedebuglog('i', 'CH' + str(channel) + ': Output lamps ON')
        else:
          writedebuglog('i', 'CH' + str(channel) + ': Output lamps OFF')
        if out_vents[channel] == 1:
          writedebuglog('i', 'CH' + str(channel) + ': Output ventilators ON')
        else:
          writedebuglog('i', 'CH' + str(channel) + ': Output ventilators OFF')

# initialize GPIO/LPT port
def initializelocalports():
  writedebuglog('i', 'Initializing local I/O ports.')
  if HW == 0:
    # GPIO ports
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(gpio_i1, GPIO.IN)
    GPIO.setup(gpio_i2, GPIO.IN)
    GPIO.setup(gpio_i3, GPIO.IN)
    GPIO.setup(gpio_i4, GPIO.IN)
    GPIO.setup(gpio_i5, GPIO.IN)
    GPIO.setup(gpio_lo1, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_lo2, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_lo3, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_lo4, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro1, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro1, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro2, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro3, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro5, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro6, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro7, GPIO.OUT, initial=GPIO.LOW)
    GPIO.setup(gpio_ro8, GPIO.OUT, initial=GPIO.LOW)
  else:
    # paralel (LPT) port
    for i in range(0,3):
      status = portio.ioperm(lpt_address + i, 1, 1)
      if status:
        writedebuglog('e', 'ERROR #17: Cannot access I/O port: ' + str(hex(lpt_address + i)) + '!')
        sys.exit(17)
    portio.outb(0, lpt_address)
    # GPIO port of IPC
    if (ipc_gpio_enable) or (ipc_led_enable):
      if not ipc.setup():
        writedebuglog('e', 'ERROR #17: Cannot access GPIO port!')
        sys.exit(17)
    if ipc_gpio_enable:
      ipc.output(ipc_gpio_ro1, 0)
      ipc.output(ipc_gpio_ro2, 0)
      ipc.output(ipc_gpio_ro3, 0)
      ipc.output(ipc_gpio_ro4, 0)
    if ipc_led_enable:
      ipc.leds(ipc_led_alarm, 0)
      ipc.leds(ipc_led_status, 0)

# write data to GPIO/LPT port
def writelocalports():
  if HW == 0:
    # GPIO ports
    try:
      GPIO.output(gpio_lo1, led_active)
      GPIO.output(gpio_lo2, led_warning)
      GPIO.output(gpio_lo3, led_error)
      GPIO.output(gpio_lo4, led_waterpumperror)
      GPIO.output(gpio_ro1, relay_alarm)
      GPIO.output(gpio_ro2, relay_tube1)
      GPIO.output(gpio_ro3, relay_tube2)
      GPIO.output(gpio_ro4, relay_tube3)
      # unused outputs
      GPIO.output(gpio_ro5, 0)
      GPIO.output(gpio_ro6, 0)
      GPIO.output(gpio_ro7, 0)
      GPIO.output(gpio_ro8, 0)
      return 1
    except:
      return 0
  else:
    # GPIO port of IPC
    if ipc_led_enable:
      ipc.leds(ipc_led_alarm, led_error)
      ipc.leds(ipc_led_status, led_active)
    if ipc_gpio_enable:
      ipc.output(ipc_gpio_ro1, relay_alarm)
      ipc.output(ipc_gpio_ro2, relay_tube1)
      ipc.output(ipc_gpio_ro3, relay_tube2)
      ipc.output(ipc_gpio_ro4, relay_tube3)
    # paralel (LPT) port
    lpterror = 0
    outdata = 0
    outbit = 0
    outbit = lpt_bits[5][2] ^ led_active
    outdata = outdata | (2 ** lpt_bits[5][1]) * outbit
    outbit = lpt_bits[6][2] ^ led_warning
    outdata = outdata | (2 ** lpt_bits[6][1]) * outbit
    outbit = lpt_bits[7][2] ^ led_error
    outdata = outdata | (2 ** lpt_bits[7][1]) * outbit
    outbit = lpt_bits[8][2] ^ led_waterpumperror
    outdata = outdata | (2 ** lpt_bits[8][1]) * outbit
    portio.outb(outdata,lpt_address + lpt_bits[5][0])
    if (0x0F & portio.inb(lpt_address + lpt_bits[5][0]) == outdata):
      outdata = 0
      outbit = 0
      outbit = lpt_bits[9][2] ^ relay_alarm
      outdata = outdata | (2 ** lpt_bits[9][1]) * outbit
      outbit = lpt_bits[10][2] ^ relay_tube1
      outdata = outdata | (2 ** lpt_bits[10][1]) * outbit
      outbit = lpt_bits[11][2] ^ relay_tube2
      outdata = outdata | (2 ** lpt_bits[11][1]) * outbit
      outbit = lpt_bits[12][2] ^ relay_tube3
      outdata = outdata | (2 ** lpt_bits[12][1]) * outbit
      # unused outputs
      outbit = lpt_bits[13][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[13][1]) * outbit
      outbit = lpt_bits[14][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[14][1]) * outbit
      outbit = lpt_bits[15][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[15][1]) * outbit
      outbit = lpt_bits[16][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[16][1]) * outbit
      portio.outb(outdata,lpt_address + lpt_bits[9][0])
      if (portio.inb(lpt_address + lpt_bits[9][0]) != outdata):
        lpterror = 1
    else:
      lpterror = 1
    return not lpterror

# read data from GPIO/LPT port
def readlocalports():
  global mainsbreakers
  global waterpressurelow
  global waterpressurehigh
  if HW == 0:
    # GPIO ports
    try:
      mainsbreakers = GPIO.input(gpio_i1)
      waterpressurelow = GPIO.input(gpio_i2)
      waterpressurehigh = GPIO.input(gpio_i3)
      # unused1 = GPIO.input(gpio_i4)
      # unused2 = GPIO.input(gpio_i5)
      return 1
    except:
      mainsbreakers = 0;
      waterpressurelow = 0
      waterpressurehigh = 0
      return 0
  else:
    # paralel (LPT) port
    try:
      indata = portio.inb(lpt_address + lpt_bits[0][0])
      mainsbreakers = indata & (2 ** lpt_bits[0][1])
      waterpressurelow = indata & (2 ** lpt_bits[1][1])
      waterpressurehigh = indata & (2 ** lpt_bits[2][1])
      # unused1 = indata & (2 ** lpt_bits[3][1])
      # unused2 = indata & (2 ** lpt_bits[4][1])
      mainsbreakers = 1 if mainsbreakers >= 1 else 0
      waterpressurelow = 1 if waterpressurelow >=1 else 0
      waterpressurehigh = 1 if waterpressurehigh >=1 else 0
      # unused1 = 1 if unused1 >=1 else 0
      # unused2 = 1 if unused2 >=1 else 0
      mainsbreakers = lpt_bits[0][2] ^ mainsbreakers
      waterpressurelow = lpt_bits[1][2] ^ waterpressurelow
      waterpressurehigh = lpt_bits[2][2] ^ waterpressurehigh
      # unused1 = lpt_bits[3][2] ^ unused1
      # unused2 = lpt_bits[4][2] ^ unused2
      return 1
    except:
      mainsbreakers = 0;
      waterpressurelow = 0
      waterpressurehigh = 0
      # unused1 = 0
      # unused2 = 0
      return 0

# close GPIO/LPT port
def closelocalports():
  writedebuglog('i', 'Close local I/O ports.')
  if HW == 0:
    GPIO.cleanup
  else:
    if ipc_led_enable:
      ipc.leds(ipc_led_alarm, 0)
      ipc.leds(ipc_led_status, 0)
    if ipc_gpio_enable:
      ipc.output(ipc_gpio_ro1, 0)
      ipc.output(ipc_gpio_ro2, 0)
      ipc.output(ipc_gpio_ro3, 0)
      ipc.output(ipc_gpio_ro4, 0)
    lpterror = 0
    outdata = 0
    outbit = 0
    outdata = 0
    outbit = 0
    outbit = lpt_bits[5][2] ^ 0
    outdata = outdata | (2 ** lpt_bits[5][1]) * outbit
    outbit = lpt_bits[6][2] ^ 0
    outdata = outdata | (2 ** lpt_bits[6][1]) * outbit
    outbit = lpt_bits[7][2] ^ 0
    outdata = outdata | (2 ** lpt_bits[7][1]) * outbit
    outbit = lpt_bits[8][2] ^ 0
    outdata = outdata | (2 ** lpt_bits[8][1]) * outbit
    portio.outb(outdata, lpt_address + lpt_bits[5][0])
    if (0x0F & portio.inb(lpt_address + lpt_bits[5][0]) == outdata):
      outdata = 0
      outbit = 0
      outbit = lpt_bits[9][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[9][1]) * outbit
      outbit = lpt_bits[10][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[10][1]) * outbit
      outbit = lpt_bits[11][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[11][1]) * outbit
      outbit = lpt_bits[12][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[12][1]) * outbit
      outbit = lpt_bits[13][2] ^ 0
      # unused outputs
      outdata = outdata | (2 ** lpt_bits[13][1]) * outbit
      outbit = lpt_bits[14][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[14][1]) * outbit
      outbit = lpt_bits[15][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[15][1]) * outbit
      outbit = lpt_bits[16][2] ^ 0
      outdata = outdata | (2 ** lpt_bits[16][1]) * outbit
      portio.outb(outdata,lpt_address + lpt_bits[9][0])
      if (portio.inb(lpt_address + lpt_bits[9][0]) != outdata):
        lpterror = 1
    else:
      lpterror = 1
    return not lpterror

# read remote MM7D device
def readMM7Ddevice(channel):
  rc = 0
  modbusid = mm7dch_modbusid[channel]
  protocol = mm7d_protocol
  serport = mm7d_port
  serspeed = mm7d_speed
  url = mm7dch_ipaddress[channel]
  if protocol == HT:
    url = 'http://' + mm7dch_ipaddress[channel] + '/get/txt'
  try:
    if mm7d_protocol == HT:
      r = requests.get(url,timeout = 3)
      if r.status_code == 200:
        rc = 1
        l = 0
        for line in r.text.splitlines():
          l = l + 1
          if l == 7:
            in_humidity[channel] = int(line)
          if l == 8:
            in_temperature[channel] = int(line) - 273
          if l == 9:
            in_5v[channel] = int(line)
      else:
        rc = 0
    else:
      if protocol == MT:
        mb_client = ModbusTcpClient(url, MB_PORT)
      if protocol == MR:
        mb_client = ModbusSerialClient(method='rtu', port=serport, baudrate=serspeed)
      mb_reg = 0
      mb_regs = 3
      mb_client.connect()
      if protocol == MT:
        mb_result = mb_client.read_input_registers(mb_reg, mb_regs)
      if protocol == MR:
        mb_result = mb_client.read_input_registers(mb_reg, mb_regs, modbusid)
      in_humidity[channel] = mb_result.registers[0]
      in_temperature[channel] = mb_result.registers[1] - 273
      in_5v[channel] = mb_result.registers[2]
      mb_client.close()
      rc = 1
    time.sleep(DELAY)
  except:
    rc = 0
  return rc

# read remote MM6D device
def readMM6Ddevice(channel):
  rc = 0
  modbusid = mm6dch_modbusid[channel]
  protocol = mm6d_protocol
  url = mm6dch_ipaddress[channel]
  if protocol == HT:
    url = 'http://' + mm6dch_ipaddress[channel] + '/get/txt'
  try:
    if mm6d_protocol == HT:
      r = requests.get(url,timeout = 3)
      if r.status_code == 200:
        rc = 1
        l = 0
        for line in r.text.splitlines():
          l = l + 1
          if l == 7:
            in_error[channel] = int(line)
          if l == 8:
            in_alarm[channel] = int(line)
          if l == 9:
            in_ocprot[channel] = int(line)
          if l == 11:
            if int(line) == 1:
              in_opmode[channel] = 0
          if l == 12:
            if int(line) == 1:
              in_opmode[channel] = 1
          if l == 13:
            if int(line) == 1:
              in_opmode[channel] = 2
          if l == 14:
            in_swmanu[channel] = int(line)
      else:
        rc = 0
    else:
      if protocol == MT:
        mb_client = ModbusTcpClient(url, MB_PORT)
      if protocol == MR:
        mb_client = ModbusSerialClient(method='rtu', port=serport, baudrate=serspeed)
      mb_reg = 0
      mb_regs = 8
      mb_client.connect()
      if protocol == MT:
        mb_result = mb_client.read_discrete_inputs(mb_reg, mb_regs)
      if protocol == MR:
        mb_result = mb_client.read_discrete_inputs(mb_reg, mb_regs, modbusid)
      in_error[channel] = int(mb_result.bits[0])
      in_alarm[channel] = int(mb_result.bits[1])
      in_ocprot[channel] = int(mb_result.bits[2])
      for i in range(0,3):
        if mb_result.bits[4 + i] == 1:
          in_opmode[channel] = i
      in_swmanu[channel] = int(mb_result.bits[7])
      mb_client.close()
      rc = 1
    time.sleep(DELAY)
  except:
    rc = 0
  return rc

# write remote MM6D device
def writeMM6Ddevice(channel):
  rc = 0
  modbusid = mm6dch_modbusid[channel]
  protocol = mm6d_protocol
  url = mm6dch_ipaddress[channel]
  if protocol == HT:
    url = 'http://' + mm6dch_ipaddress[channel] + '/set?'
  try:
    if mm6d_protocol == HT:
      url = url + 'lamp=' + str(out_lamps[channel]) + '&vent=' + str(out_vents[channel]) + '&heat=' + str(out_heaters[channel])
      r = requests.get(url,timeout = 3)
      if r.status_code == 200:
        rc = 1
      else:
        rc = 0
    else:
      if protocol == MT:
        mb_client = ModbusTcpClient(url, MB_PORT)
      if protocol == MR:
        mb_client = ModbusSerialClient(method='rtu', port=serport, baudrate=serspeed)
      mb_reg = 0
      mb_client.connect()
      if protocol == MT:
        mb_client.write_coil(mb_reg, bool(out_lamps[channel]))
        mb_client.write_coil(mb_reg + 1, bool(out_vents[channel]))
        mb_client.write_coil(mb_reg + 2, bool(out_heaters[channel]))
      if protocol == MR:
        mb_client.write_coil(mb_reg, bool(out_lamps[channel]), modbusid)
        mb_client.write_coil(mb_reg + 1, bool(out_vents[channel]), modbusid)
        mb_client.write_coil(mb_reg + 2, bool(out_heaters[channel]), modbusid)
      mb_client.close()
      rc = 1
    time.sleep(DELAY)
  except:
    rc = 0
  return rc

# set default state of the remote MM6D device
def resetMM6Ddevice(channel):
  rc = 0
  modbusid = mm6dch_modbusid[channel]
  protocol = mm6d_protocol
  url = mm6dch_ipaddress[channel]
  if protocol == HT:
    url = 'http://' + mm6dch_ipaddress[channel] + '/set?'
  try:
    if mm6d_protocol == HT:
      url = url + 'lamp=0&vent=0&heat=0'
      r = requests.get(url,timeout = 3)
      if r.status_code == 200:
        rc = 1
      else:
        rc = 0
    else:
      if protocol == MT:
        mb_client = ModbusTcpClient(url, MB_PORT)
      if protocol == MR:
        mb_client = ModbusSerialClient(method='rtu', port=serport, baudrate=serspeed)
      mb_reg = 0
      mb_client.connect()
      if protocol == MT:
        mb_client.write_coil(mb_reg, 0)
        mb_client.write_coil(mb_reg + 1, 0)
        mb_client.write_coil(mb_reg + 2, 0)
      if protocol == MR:
        mb_client.write_coil(mb_reg, 0, modbusid)
        mb_client.write_coil(mb_reg + 1, 0, modbusid)
        mb_client.write_coil(mb_reg + 2, 0, modbusid)
      mb_client.close()
      rc = 1
    time.sleep(DELAY)
  except:
    rc = 0
  return rc
 
# get version of the remote MM6D or MM7D device
def getcontrollerversion(conttype,channel):
  global mv
  global sv
  global rev
  mv = 0
  sv = 0
  rev = 0
  rc = 0
  if conttype == 6:
    modbusid = mm6dch_modbusid[channel]
    protocol = mm6d_protocol
    url = mm6dch_ipaddress[channel]
    if protocol == HT:
      url = 'http://' + mm6dch_ipaddress[channel] + '/get/txt'
  if conttype == 7:
    modbusid = mm7dch_modbusid[channel]
    protocol = mm7d_protocol
    url = mm7dch_ipaddress[channel]
    if protocol == HT:
      url = 'http://' + mm7dch_ipaddress[channel] + '/get/txt'
  try:
    if protocol == HT:
      r = requests.get(url,timeout = 3)
      if r.status_code == 200:
        rc = 1
        l = 0
        for line in r.text.splitlines():
          l = l + 1
          if l == 1:
            writedebuglog('i', 'CH' + str(channel) + ' ' + line + ':')
          if l == 2:
            writedebuglog('i', '- Software version: ' + line)
            mv = int(line[0])
            sv = int(line[2])
            rev = int(line[4])
          if l == 3:
            writedebuglog('i', '- MAC address: ' + line)
          if l == 4:
            writedebuglog('i', '- IP address: ' + line)
          if l == 5:
            writedebuglog('i', '- Modbus ID: ' + line)
      else:
          rc = 0
    else:
      if protocol == MT:
        mb_client = ModbusTcpClient(url, MB_PORT)
      if protocol == MR:
        mb_client = ModbusSerialClient(method='rtu', port=serport,baudrate=serspeed)
      mb_reg = 0
      mb_regs = 3
      mb_client.connect()
      if protocol == MT:
        mb_result = mb_client.read_input_registers(mb_reg, mb_regs)
      if protocol == MR:
        mb_result = mb_client.read_input_registers(mb_reg, mb_regs, modbusid)
      mb_reg = 0
      mb_regs = 22
      mb_client.connect()
      mb_result = mb_client.read_holding_registers(mb_reg, mb_regs)
      line = '' 
      for i in range(0,8):
        if mb_result.registers[i] > 0:
          line = line + chr(mb_result.registers[i])
      writedebuglog('i', 'CH' + str(channel) + ' ' + line + ':')
      mv = mb_result.registers[8]
      sv = mb_result.registers[9]
      rev = mb_result.registers[10]
      line = str(mv) + '.' + str(sv) + '.' + str(rev)
      writedebuglog('i', '- Software version: ' + line)
      line = ''
      for i in range(11,17):
        line = line + str(hex(mb_result.registers[i])[2:])
        if i < 16:
          line = line + ':'
      writedebuglog('i', '- MAC address: ' + line.upper())
      line = ''
      for i in range(17,21):
        line = line + str(mb_result.registers[i])
        if i < 20:
          line = line + '.'
      writedebuglog('i', '- IP address: ' + line)
      writedebuglog('i', '- Modbus ID: ' + str(mb_result.registers[21]))
      mb_client.close()
      rc = 1
    time.sleep(DELAY)
  except:
    rc = 0
  return rc

# main program
global com
global exttemp
global fwm_qv
global hheater_disable
global hheater_off
global hheater_on
global hhumidifier_disable
global hhumidifier_off
global hhumidifier_on
global hhumidity_max
global hhumidity_min
global hlight_off1
global hlight_off2
global hlight_on1
global hlight_on2
global htemperature_max
global htemperature_min
global hvent_disable
global hvent_disablehightemp
global hvent_disablelowtemp
global hvent_hightemp
global hvent_lowtemp
global hvent_off
global hvent_on
global in_5v
global in_alarm
global in_error
global in_humidity
global in_ocprot
global in_opmode
global in_swmanu
global in_temperature
global led_active
global led_error
global led_warning
global led_waterpumperror
global loop
global mheater_disable
global mheater_off
global mheater_on
global mhumidifier_disable
global mhumidifier_off
global mhumidifier_on
global mhumidity_max
global mhumidity_min
global mlight_off1
global mlight_off2
global mlight_on1
global mlight_on2
global mtemperature_max
global mtemperature_min
global mvent_disable
global mvent_disablehightemp
global mvent_disablelowtemp
global mvent_hightemp
global mvent_lowtemp
global mvent_off
global mvent_on
global out_heaters
global out_lamps
global out_vents
global override
global pwm_cosfi
global pwm_irms
global pwm_p
global pwm_q
global pwm_s
global pwm_urms
global relay_alarm
global relay_tube1
global relay_tube2
global relay_tube3
global HT
global MR
global MT

# reset variables
done = 0
exttemp = 18
fwm_qv = 0
hheater_disable = [[0 for x in range(9)] for y in range(24)]
hheater_off = [0 for x in range(9)]
hheater_on = [0 for x in range(9)]
hhumidifier_off = [0 for x in range(9)]
hhumidifier_on = [0 for x in range(9)]
hhumidity_max = [0 for x in range(9)]
hhumidity_min = [0 for x in range(9)]
hlight_off1 = [0 for x in range(9)]
hlight_off2 = [0 for x in range(9)]
hlight_on1 = [0 for x in range(9)]
hlight_on2 = [0 for x in range(9)]
htemperature_max = [0 for x in range(9)]
htemperature_min = [0 for x in range(9)]
hvent_disable = [[0 for x in range(9)] for x in range(24)]
hvent_disablehightemp = [[0 for x in range(9)] for x in range(24)]
hvent_disablelowtemp = [[0 for x in range(9)] for x in range(24)]
hvent_hightemp = [0 for x in range(9)]
hvent_lowtemp = [0 for x in range(9)]
hvent_off = [0 for x in range(9)]
hvent_on = [0 for x in range(9)]
in_5v = [0 for channel in range(9)]
in_alarm = [0 for channel in range(9)]
in_error = [0 for channel in range(9)]
in_humidity = [0 for channel in range(9)]
in_ocprot = [0 for channel in range(9)]
in_opmode = [0 for channel in range(9)]
in_swmanu = [0 for channel in range(9)]
in_temperature = [0 for channel in range(9)]
led_active = 0
led_error = 0
led_warning = 0
led_waterpumperror = 0
loop = 0
mheater_disable = [[0 for x in range(9)] for y in range(24)]
mheater_off = [0 for x in range(9)]
mheater_on = [0 for x in range(9)]
mhumidifier_off = [0 for x in range(9)]
mhumidifier_on = [0 for x in range(9)]
mhumidity_max = [0 for x in range(9)]
mhumidity_min = [0 for x in range(9)]
mlight_off1 = [0 for x in range(9)]
mlight_off2 = [0 for x in range(9)]
mlight_on1 = [0 for x in range(9)]
mlight_on2 = [0 for x in range(9)]
mtemperature_max = [0 for x in range(9)]
mtemperature_min = [0 for x in range(9)]
mvent_disable = [[0 for x in range(9)] for x in range(24)]
mvent_disablehightemp = [[0 for x in range(9)] for x in range(24)]
mvent_disablelowtemp = [[0 for x in range(9)] for x in range(24)]
mvent_hightemp = [0 for x in range(9)]
mvent_lowtemp = [0 for x in range(9)]
mvent_off = [0 for x in range(9)]
mvent_on = [0 for x in range(9)]
newdata_ch = ['' for x in range(10)]
newdata_ps = ['' for x in range(10)]
out_heaters = [0 for channel in range(9)]
out_lamps = [0 for channel in range(9)]
out_vents = [0 for channel in range(9)]
override = [['neutral' for x in range(4)] for x in range(9)]
prevdata_ch = ['' for x in range(10)]
prevdata_ps = ''
pwm_cosfi = 0
pwm_irms = 0
pwm_p = 0
pwm_q = 0
pwm_s = 0
pwm_urms = 0
relay_alarm = 0
relay_tube1 = 0
relay_tube2 = 0
relay_tube3 = 0
HT = 'http'
MR = 'rtu'
MT = 'tcp'
# load main settings
loadconfiguration(CONFDIR + 'mm8d.ini')
# load modules
if (ipc_gpio_enable) or (ipc_led_enable) == 1:
  ipc = __import__(ipc_gpio_handler)
if fwm_enable == 1:
  fwm = __import__(fwm_handler)
  fwm.baudrate = fwm_speed
  fwm.port = fwm_port
if pwm_enable == 1:
  pwm = __import__(pwm_handler)
  pwm.baudrate = pwm_speed
  pwm.port = pwm_port
if otm_enable == 1:
  otm = __import__(otm_handler)
  otm.baudrate = otm_speed
  otm.port = otm_port
if tdp_enable == 1:
  tdp = __import__(tdp_handler)
  tdp.baudrate = tdp_speed
  tdp.port = tdp_port
# clear tent display
for channel in range(1,9):
  if ch_enable[channel] == 1:
    if tdp_enable == 1:
      if tdp.cleardisplay(tdpch_modbusid[channel]): 
        writedebuglog('i', 'CH' + str(channel) + ': Clear tent display.')
      else:
        writedebuglog('w', 'CH' + str(channel) + ': Cannot clear tent display.')
# intialize serial port of console
if msc_enable == 1:
  com = serial.Serial(msc_port, msc_speed)
# load irrigator settings
loadirrconf(CONFDIR + 'irrigator.ini')
# checking version of remote devices
for channel in range(1,9):
  if ch_enable[channel] > 0:
    if getcontrollerversion(6,channel):
      if (mv * 10 + sv) < (COMPMV6 * 10 + COMPSV6):
        ch_enable[channel] = 0;
        writedebuglog('w', 'CH' + str(channel) + ': Version of MM6D is not compatible.')
    else:
      ch_enable[channel] = 0;
      writedebuglog('w', 'CH' + str(channel) + ': MM6D is not accessible.')
for channel in range(1,9):
  if ch_enable[channel] > 0:
    if getcontrollerversion(7,channel):
      if (mv * 10 + sv) < (COMPMV7 * 10 + COMPSV7):
        ch_enable[channel] = 0;
        writedebuglog('w', 'CH' + str(channel) + ': Version of MM7D is not compatible.')
    else:
      ch_enable[channel] = 0;
      writedebuglog('w', 'CH' + str(channel) + ': MM7D is not accessible.')
# check number of enabled channels
ii = 0;
for channel in range(1,9):
  ii=ii+ch_enable[channel];
# Error #18 -> warning
if ii == 0:
  # writedebuglog('e', 'ERROR #18: There is not enabled channel!')
  # exit(18);
  writedebuglog('w', 'There is not enabled channel!')
# load environment parameter settings
for channel in range(1,9):
  if ch_enable[channel] == 1:
    loadenvirconf(channel,CONFDIR + 'envir-ch' + str(channel) + '.ini')
# initialize local ports to default state
initializelocalports()
# get or measure external temperature
exttemp = 18
if owm_enable == 1:
  exttemp = getexttemp()
# get outdoor temperature from meter
if otm_enable == 1:
  if otm.readregisters(otm_modbusid) == 1:
    writedebuglog('i', 'Get data from outdoor temperature meter.')
    try: 
      exttemp = round(otm.gett())
    except:
      exttemp = 18
      writedebuglog('w', 'Cannot get data from outdoor temperature meter.')
  else:
    writedebuglog('w', 'Cannot get data from outdoor temperature meter.')
writedebuglog('i', 'External temperature: ' + str(exttemp) + ' degree Celsius')
# *** start loop ***
writedebuglog('i', 'Starting program as daemon.')
time.sleep(1)
while True:
  try:
    led_active = 1
    writelocalports()
    # section #1:
    # read data from local port
    writedebuglog('i', 'Read data from local I/O port.')
    if readlocalports():
      writedebuglog('i', 'Input data:')
      writedebuglog('i', '- Pressure high:  ' + str(waterpressurehigh))
      writedebuglog('i', '- Pressure low:   ' + str(waterpressurelow))
      writedebuglog('i', '- Mains breakers: ' + str(mainsbreakers))
    else:
      writedebuglog('w', 'Cannot read data from local I/O port.')
    # analise data
    analise(1);
    # override state of outputs
    relay_tube1 = int(outputoverride(0, 1, relay_tube1))
    relay_tube2 = int(outputoverride(0, 2, relay_tube2))
    relay_tube3 = int(outputoverride(0, 3, relay_tube3))
    if relay_tube1 == 1:
      writedebuglog('i', 'CH0: -> water pump and valve #1 ON')
    else:
      writedebuglog('i', 'CH0: -> water pump and valve #1 OFF')
    if relay_tube2 == 1:
      writedebuglog('i', 'CH0: -> water pump and valve #2 ON')
    else:
      writedebuglog('i', 'CH0: -> water pump and valve #2 OFF')
    if relay_tube3 == 1:
      writedebuglog('i', 'CH0: -> water pump and valve #3 ON')
    else:
      writedebuglog('i', 'CH0: -> water pump and valve #3 OFF')
    # write data to local port
    writedebuglog('i', 'Write data to local I/O port.')
    if writelocalports():
      writedebuglog('i', 'Output data:')
      writedebuglog('i', '- Pump error LED:      ' + str(led_waterpumperror))
      writedebuglog('i', '- General error LED:   ' + str(led_error))
      writedebuglog('i', '- General warning LED: ' + str(led_warning))
      writedebuglog('i', '- Active LED:          ' + str(led_active))
      writedebuglog('i', '- Tube #3 relay:       ' + str(relay_tube3))
      writedebuglog('i', '- Tube #2 relay:       ' + str(relay_tube2))
      writedebuglog('i', '- Tube #1 relay:       ' + str(relay_tube1))
      writedebuglog('i', '- Alarm relay:         ' + str(relay_alarm))
    else:
      writedebuglog('w', 'Cannot write data to local I/O port.')
    # get status and set outputs of the MM6D
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        if writeMM6Ddevice(channel):
          writedebuglog('i', 'CH' + str(channel) + ': Set outputs of the MM6D.')
        else:
          writedebuglog('w', 'CH' + str(channel) + ': Cannot set outputs of the MM6D.')
        if readMM6Ddevice(channel):
          writedebuglog('i', 'CH' + str(channel) + ': Get status of the MM6D.')
        else:
          writedebuglog('w', 'CH' + str(channel) + ': Cannot get status of the MM6D.')
    # section #2:
    # get data from electricity consumption meter
    if pwm_enable == 1:
      if pwm.readregisters(pwm_modbusid) == 1:
        writedebuglog('i', 'Get data from consumption meter.')
        try:
          pwm_p = round(pwm.getp())
          pwm_q = round(pwm.getq())
          pwm_s = round(pwm.gets())
          pwm_urms = round(pwm.geturms())
          pwm_irms = round(pwm.getirms())
          pwm_cosfi = round(pwm.getcosfi())
        except:
          pwm_p = 0
          pwm_q = 0
          pwm_s = 0
          pwm_urms = 0
          pwm_irms = 0
          pwm_cosfi = 0
          writedebuglog('w', 'Cannot get data from consumption meter.')
      else:
        writedebuglog('w', 'Cannot get data from consumption meter.')
      writedebuglog('i', 'Mains voltage: ' + str(pwm_urms) + ' V')
      writedebuglog('i', 'Mains current: ' + str(pwm_irms) + ' A')
    # get data from water flow meter
    if fwm_enable == 1:
      if fwm.readregisters(fwm_modbusid) == 1:
        writedebuglog('i', 'Get data from water flow meter.')
        fwm_qv = fwm.getqv
        writedebuglog('i', 'Water flow: ' + str(fwm_qv) + ' l/h')
      else:
        writedebuglog('w', 'Cannot get data from water flow meter.')
    # get data from MM7Ds
    for channel in range(1,9):
      if ch_enable[channel] == 1:
       if readMM7Ddevice(channel):
         writedebuglog('i', 'CH' + str(channel) + ': Get data from the MM7D.')
       else:
         writedebuglog('w', 'CH' + str(channel) + ': Cannot get data from the MM7D.')
    # get outdoor temperature from internet
    if (int(time.strftime('%M')) == 0) or (int(time.strftime('%M')) == 1):
      if done == 0:
        if owm_enable == 1:
          exttemp = getexttemp()
        done = 1
    if (int(time.strftime('%M')) == 30) or (int(time.strftime('%M')) == 31):
      done = 0
    # get outdoor temperature from meter
    if otm_enable == 1:
      if otm.readregisters(otm_modbusid) == 1:
        writedebuglog('i', 'Get data from outdoor temperature meter.')
        try: 
          exttemp = round(otm.gett())
        except:
          exttemp = 18
          writedebuglog('w', 'Cannot get data from outdoor temperature meter.')
      else:
        writedebuglog('w', 'Cannot get data from outdoor temperature meter.')
    writedebuglog('i', 'External temperature: ' + str(exttemp) + ' degree Celsius')
    # analise data
    analise(2);
    # override state of outputs
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        out_lamps[channel] = outputoverride(channel,1,out_lamps[channel])
        out_vents[channel] = outputoverride(channel,2,out_vents[channel])
        out_heaters[channel] = outputoverride(channel,3,out_heaters[channel])
        if out_heaters[channel] == 1:
          writedebuglog('i', 'CH' + str(channel) + ': -> heaters ON')
        else:
          writedebuglog('i', 'CH' + str(channel) + ': -> heaters OFF')
        if out_lamps[channel] == 1:
          writedebuglog('i', 'CH' + str(channel) + ': -> lamps ON')
        else:
          writedebuglog('i', 'CH' + str(channel) + ': -> lamps OFF')
        if out_vents[channel] == 1:
          writedebuglog('i', 'CH' + str(channel) + ': -> ventilators ON')
        else:
          writedebuglog('i', 'CH' + str(channel) + ': -> ventilators OFF')
    # write data to mm8d-ch0.log
    newdata_ch[0] = str(mainsbreakers) + \
                    str(waterpressurelow) + \
                    str(waterpressurehigh) + \
                    str(relay_tube1) + \
                    str(relay_tube2) + \
                    str(relay_tube3)
    if (prevdata_ch[0] != str(exttemp) + newdata_ch[0]):
      writechannelstatustolog(0,exttemp,0,newdata_ch[0])
      prevdata_ch[0] = str(exttemp) + newdata_ch[0]
    # write data to mm8d-ch[1-8].log
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        if in_temperature[channel] + in_humidity[channel] > 0:
          newdata_ch[channel] = str(in_error[channel]) + \
                                str(in_opmode[channel]) + \
                                str(in_swmanu[channel]) + \
                                str(in_ocprot[channel]) + \
                                str(in_alarm[channel]) + \
                                str(out_lamps[channel]) + \
                                str(out_vents[channel]) + \
                                str(out_heaters[channel])
          if (prevdata_ch[channel] != str(in_temperature[channel]) + str(in_humidity[channel]) + newdata_ch[channel]):
            writechannelstatustolog(channel, in_temperature[channel],in_humidity[channel],newdata_ch[channel])
            prevdata_ch[channel] = str(in_temperature[channel]) + str(in_humidity[channel]) + newdata_ch[channel]
    # write data to mm8d-supply.log
    if pwm_enable == 1:
        newdata_ps = str(pwm_urms) + \
                     str(pwm_irms) + \
                     str(pwm_p) + \
                     str(pwm_q) + \
                     str(pwm_s) + \
                     str(pwm_cosfi) + \
                     str(fwm_qv)
        if (prevdata_ps != newdata_ps):
          writesupplydatatolog(pwm_urms, pwm_irms, pwm_p, pwm_q, pwm_s, pwm_cosfi, fwm_qv)
          prevdata_ps = newdata_ps
    # write data to the tent display
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        if tdp_enable == 1:
          if in_temperature[channel] < 0: s = '00'
          if in_temperature[channel] < 10:
            s = '0' + str(in_temperature[channel])
          else:
            s = str(in_temperature[channel])
          if in_temperature[channel] > 99: s = '99'
          s = s + ' '
          if in_humidity[channel] < 0: s = s + '000'
          if in_humidity[channel] < 10: s = s + '00' + str(in_humidity[channel])
          if in_humidity[channel] < 100:
            s = s + '0' + str(in_humidity[channel])
          else:
            s = s + '100'
          if tdp.writestr(tdpch_modbusid[channel], s):
            writedebuglog('i', 'CH' + str(channel) + ': Write T/RH to the tent display.')
          else:
            writedebuglog('w', 'CH' + str(channel) + ': Cannot write T/RH to the tent display.')
    # send channels' data to display via serial port
    writechannelstatustocomport(loop)
    if loop == 8:
      loop = 0
    else:
      loop = loop + 1
    # waiting
    led_active = 0
    writelocalports()
    writedebuglog('i', 'Waiting ' + str(DELAY) + ' seconds.')
    time.sleep(DELAY)
  except:
    # *** stop loop ***
    writedebuglog('e', 'ERROR #19: Fatal error!')
    # close local ports
    closelocalports()
    # clear tent display
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        if tdp_enable == 1:
          if tdp.cleardisplay(tdpch_modbusid[channel]): 
            writedebuglog('i', 'CH' + str(channel) + ': Clear tent display.')
          else:
            writedebuglog('w', 'CH' + str(channel) + ': Cannot clear tent display.')
    # set outputs of MM6D
    for channel in range(1,9):
      if ch_enable[channel] == 1:
        if resetMM6Ddevice(channel):
          writedebuglog('i', 'CH' + str(channel) + ': Set outputs of the MM6D to default state.')
        else:
          writedebuglog('w', 'CH' + str(channel) + ': Cannot set outputs of the MM6D to default state.')
    writedebuglog('i', 'Program stopped.')
    sys.exit(19)
# close local ports
closelocalports()
# set outputs of MM6D
for channel in range(1,9):
  if ch_enable[channel] == 1:
    if resetMM6Ddevice(channel):
      writedebuglog('i', 'CH' + str(channel) + ': Set outputs of the MM6D to default state.')
    else:
      writedebuglog('w', 'CH' + str(channel) + ': Cannot set outputs of the MM6D to default state.')
# clear tent display
for channel in range(1,9):
  if ch_enable[channel] == 1:
    if tdp_enable == 1:
      if tdp.cleardisplay(tdpch_modbusid[channel]): 
        writedebuglog('i', 'CH' + str(channel) + ': Clear tent display.')
      else:
        writedebuglog('w', 'CH' + str(channel) + ': Cannot clear tent display.')
writedebuglog('i', 'Program stopped.')
sys.exit(0)
